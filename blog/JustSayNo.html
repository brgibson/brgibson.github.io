<h1>Just say no! (to saying no)</h1>

<h2>When did we start saying no?</h2>

<p>
There comes a time in the growth of any company, where people stop saying "yes" and start saying "no".
</p>

<p>
Here are some of the most common rea reasons that people stop saying yes and start saying no.
</p>

<ul>
    <li>Code becomes unmanageable</li>
    <li>Developers are not following through on refactoring tasks</li>
    <li>Strict deadlines don't allow for time to fix the accumulating technical debt</li>
</ul>

<h2>
    Why process doesn't help in the long run (in fact it hurts!)
</h2>

<p>
If you are seeing your codebase go to hell and developers can't find the time to clean it up, you might start mandating code reviews or add a set of committers who are the only ones who are allowed to push code.  While this may be a good short term solution to force people to check in clean code, in the long term it can cause horrible problems.  The other problem with this kind of solution is that it doesn't address the root cause of the problem.
</p>

<p>
I can hear you all crying "sacrilige" from the peanut gallery, so let's dive into to why it doesn't work.  If mandating code reviews and adding a vangaurd of senior developers to protect the code doesn't address the root cause of the problem, the what does?  Well, first let's figure out the root cause of the problem.  If your codebase is going to hell in a handbasket, it's probobaly for a combination of the following reasons.
</p>

<ol>
    <li>Deadlines are not allowing for time to reduce technical debt</li>
    <li>Your developer ramput process is not working</li>
    <li>You aren't hiring the right people</li>
</ol>

<p>
The biggest reason why code gets messy and unmaintainable is because of deadlines.  Deadlines aren't inherently bad and they can be great ways to set expectations and get people to bear down and get something accomplished.  However, deadlines only work when they are set by the team who will be implementing the work.  If you were contracting out work to someone, you would ask them how long it is going to take.  If they can't get the work done in the timeframe you need, then you will try someone else.  The problem we often run into in technology is that we hire a number of new contractors to swarm on a feature that involves a tight deadline, but we throw them headfirst into a giant and messy codebase where we have poor rampup and expect them to succeed.  They give us an estimate of how many people it will take to get the work done in a certain amount of time, but the problem is that they don't have any experience in the codebase yet so we can't trust their estimate for time.
</p>


<ul>
    <li>Quality - You can have something done well</li>
    <li>Speed - You can have something done quickly</li>
    <li>Cost - You don't have to pay out the nose</li>
</ul>

<p>A teacher once told me that when you are contracting out work (not just technical consulting), there is a certain truth about what you can get.  For each contract, you only get to choose two of the three things above.  For example, if you want something done well and you want it done quickly, you are going to have to pay through the nose for it.  However if you want it done well, but really can't spend much money on it, then you're going to have to be patient, because it's going to take a long time.  But if you need speed and low cost, then you are going to have to sacrifice on quality.</p>

<p>This is the lesson we miss in the tech industry.  We want it done as cheaply as possible so we hire a bunch of contracters instead of using our higher paid full time employees.  We want it done quickly because business has promised this new functionality to their shareholders.  So that means, the quality of the work is not going to be good.</p>

<p>Now this is not a problem, as long as we know it is the decision we are making.</p>


<h2>
When process gets in the way of innovation
</h2>

<p>
As a company and as individuals, we must be able to take calculated risks.  We must embrace the fact that failure will happen and embrace it, learn from our mistakes, and move forward.
</p>

<p>
It is equally important to make it cheap to fail.  In order to innovate, we must be allowed to fail.  Failure should not only be accepted, but embraced.  We oftentimes experience the most personal growth from our failures.  
</p>

<h2>If you aren't failing, you're doing something wrong</h2>

<p>
If you aren't failing, then you aren't taking big enough risks.  When was the last time you heard someone say, "I made the most important changes to our company in the last ten years, and it was completely uncontroversial."  Never!  In fact, I would bet if you were explaining to someone about an amazing change you made, and you didn't have a story about how it was a big struggle to accomplish it, it would not be as impressive of a story.  It would just be too easy. 
</p>

<h2> Important changes cause the most controversy
</h2>

<p>
I would argue that the most impactful changes are the ones that are the most controvertial.  Part of the thing that makes them so impactful is the controversy itself.  It puts more responsibility on the person spearheading the change and forces everybody to hold their breath while they watch the peices fall where they may. changes that force people to pick sides and draw a line in the sand are the ones that people pay the most attention to.
</p>

<h2>Make it cheap to fail</h2>

<h2>
    Trust your coworkers
</h2>
<em>I felt like destroying something beautiful.</em>

<p>
Now, unless you're Tyler Durder, you would never actually follow through on the quote from above.  The vast majority of people are never iintentially making things worse.
</p>

<h2>
<s>Why mandating code reviews does not stop bad code:</s>
</h2>

<ul>
    <li>Just because someone reviewed it doesn't mean that it is great code</li>
    <li></li>
</ul>

<h2>
    How removing process promotes clean code
</h2>